Q1) What is hooks?
Ans:-
-------
    Hooks let you use different React features from your components. You can either use the built-in Hooks or combine 
    them to build your own.

    **State Hooks
    -----------
        State lets a component ‚Äúremember‚Äù information like user input. For example, a form component can use state 
        to store the input value, while an image gallery component can use state to store the selected image index.

        To add state to a component, use one of these Hooks:
        ----------------------------------------------------
        ==>useState declares a state variable that you can update directly.
        ==>useReducer declares a state variable with the update logic inside a reducer function.

        e.g.
        ----------------------------------
        function ImageGallery() {
        const [index, setIndex] = useState(0);
        // ...}
        ----------------------------------

    **Context Hooks 
    ---------------
        Context lets a component receive information from distant parents without passing it as props. 
        For example, your app‚Äôs top-level component can pass the current UI theme to all components below, no matter how deep.

        ==>useContext reads and subscribes to a context.
        e.g.
        ------------------------------
        function Button() {
        const theme = useContext(ThemeContext);
        // ...
        ------------------------------

    **Ref Hooks
    -----------
        Refs let a component hold some information that isn‚Äôt used for rendering, like a DOM node or a timeout ID.
        Unlike with state, updating a ref does not re-render your component. Refs are an ‚Äúescape hatch‚Äù from the React paradigm.
        They are useful when you need to work with non-React systems, such as the built-in browser APIs.

        ==>useRef declares a ref. You can hold any value in it, but most often it‚Äôs used to hold a DOM node.
        ==>useImperativeHandle lets you customize the ref exposed by your component. This is rarely used.

        e.g.
        ------------------------------ 
        function Form() {
        const inputRef = useRef(null);    
        // ...
        ------------------------------

    **Effect Hooks
    --------------
        Effects let a component connect to and synchronize with external systems. This includes dealing with network,
        browser DOM, animations, widgets written using a different UI library, and other non-React code.

        ==>useEffect connects a component to an external system.

        e.g.
        ---------------------------------------------
        function ChatRoom({ roomId }) {
            useEffect(() => {
              const connection = createConnection(roomId);
              connection.connect();
              return () => connection.disconnect();
            }, [roomId]);
            //....
        }
        ---------------------------------------------   

        Effects are an ‚Äúescape hatch‚Äù from the React paradigm. Don‚Äôt use Effects to orchestrate the data flow 
        of your application. If you‚Äôre not interacting with an external system, you might not need an Effect.

        There are two rarely used variations of useEffect with differences in timing:

        ==>useLayoutEffect fires before the browser repaints the screen. You can measure layout here.
        ==>useInsertionEffect fires before React makes changes to the DOM. Libraries can insert dynamic CSS here

    **Performance hooks
    --------------------
        A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell 
        React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.

        To skip calculations and unnecessary re-rendering, use one of these Hooks:

        useMemo lets you cache the result of an expensive calculation.
        useCallback lets you cache a function definition before passing it down to an optimized component.

        ------------------------------
        function TodoList({ todos, tab, theme }) {
         const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
        // ...
        }
        ------------------------------

        Sometimes, you can‚Äôt skip re-rendering because the screen actually needs to update. In that case,
        you can improve performance by separating blocking updates that must be synchronous (like typing into an input)
        from non-blocking updates which don‚Äôt need to block the user interface (like updating a chart).

        To prioritize rendering, use one of these Hooks:
        ------------------------------------------------
        ==>useTransition lets you mark a state transition as non-blocking and allow other updates to interrupt it.
        ==>useDeferredValue lets you defer updating a non-critical part of the UI and let other parts update first.

    **Resource Hooks 
    -----------------
        Resources can be accessed by a component without having them as part of their state. For example, a component 
        can read a message from a Promise or read styling information from a context.

        To read a value from a resource, use this Hook:
        ==>use lets you read the value of a resource like a Promise or context.
        ----------------------------------
        function MessageComponent({ messagePromise }) {
              const message = use(messagePromise);
              const theme = use(ThemeContext);
              // ...
            }
        ----------------------------------

    **Your own Hooks 
    ----------------
        You can also define your own custom Hooks as JavaScript functions.

Q2) What is UseEffect hook?
Ans:-
------
    useEffect is a React Hook that lets you synchronize a component with an external system.

***Connecting to an external system 
-----------------------------------
    Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. 
    These systems aren‚Äôt controlled by React, so they are called external.

***Usage
----------------
    ==> Connecting to an external system 
    ------------------------------------
     Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page.
     These systems aren‚Äôt controlled by React, so they are called external

    ==> Wrapping Effects in custom Hooks 


Q2) What is Error Boundary?
Ans:- 
------
    By default, if your application throws an error during rendering, React will remove its UI from the screen. 
    To prevent this, you can wrap a part of your UI into an error boundary. An error boundary is a special component 
    that lets you display some fallback UI instead of the part that crashed‚Äîfor example, an error message.
    To implement an error boundary component, you need to provide static getDerivedStateFromError which lets you 
    update state in response to an error and display an error message to the user. You can also optionally implement 
    componentDidCatch to add some extra logic, for example, to log the error to an analytics service.

    e.g.
    ---------------
    class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // Example "componentStack":
    //   in ComponentThatThrows (created by App)
    //   in ErrorBoundary (created by App)
    //   in div (created by App)
    //   in App
    logErrorToMyService(error, info.componentStack);
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return this.props.fallback;
    }

    return this.props.children;
  }
}
------------------------------------------

Then you can wrap a part of your component tree with it:

<ErrorBoundary fallback={<p>Something went wrong</p>}>
  <Profile />
</ErrorBoundary>

If Profile or its child component throws an error, ErrorBoundary will ‚Äúcatch‚Äù that error, 
display a fallback UI with the error message you‚Äôve provided, and send a production error 
report to your error reporting service.
You don‚Äôt need to wrap every component into a separate error boundary. When you think about 
the granularity of error boundaries, consider where it makes sense to display an error message. 
For example, in a messaging app, it makes sense to place an error boundary around the list of conversations.
 It also makes sense to place one around every individual message. However, it wouldn‚Äôt make sense to place a 
 boundary around every avatar.

 NOTE:-
 ------
There is currently no way to write an error boundary as a function component. However, you don‚Äôt have to write the error boundary class yourself. For example,
you can use "react-error-boundary" instead.

Q3) What is Lazy Loading ?
Ans:-
-------
lazy lets you defer loading component‚Äôs code until it is rendered for the first time.

const SomeComponent = lazy(load)
-----------------------------
Parameters 
-------------
load: A function that returns a Promise or another thenable (a Promise-like object with a then method).
React will not call load until the first time you attempt to render the returned component. 
After React first calls load, it will wait for it to resolve, and then render the resolved value‚Äôs .
default as a React component. Both the returned Promise and the Promise‚Äôs resolved value will be cached,
so React will not call load more than once. If the Promise rejects, React will throw the rejection reason
for the nearest Error Boundary to handle.

Returns 
---------
lazy returns a React component you can render in your tree. While the code for the lazy component is
still loading, attempting to render it will suspend. Use <Suspense> to display a loading indicator while it‚Äôs loading.

  **load function 
  ---------------
Parameters 
----------
load receives no parameters.

Returns 
You need to return a Promise or some other thenable (a Promise-like object with a then method). 
It needs to eventually resolve to an object whose .default property is a valid React component type,
such as a function, memo, or a forwardRef component.

Usage 
------
Lazy-loading components with Suspense 
--------------------------------------
Usually, you import components with the static import declaration:

import MarkdownPreview from './MarkdownPreview.js';
To defer loading this component‚Äôs code until it‚Äôs rendered for the first time, replace this import with:

import { lazy } from 'react';

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
This code relies on dynamic import(), which might require support from your bundler or framework..
 Using this pattern requires that the lazy component you‚Äôre importing was exported as the default export.

Now that your component‚Äôs code loads on demand, you also need to specify what should be displayed while it
is loading. You can do this by wrapping the lazy component or any of its parents into a <Suspense> boundary:

<Suspense fallback={<Loading />}>
  <h2>Preview</h2>
  <MarkdownPreview />
 </Suspense>

In this example, the code for MarkdownPreview won‚Äôt be loaded until you attempt to render it.
If MarkdownPreview hasn‚Äôt loaded yet, Loading will be shown in its place
------------------------------------------------------------------------------------
import { useState, Suspense, lazy } from 'react';
import Loading from './Loading.js';

const MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js')));

export default function MarkdownEditor() {
  const [showPreview, setShowPreview] = useState(false);
  const [markdown, setMarkdown] = useState('Hello, **world**!');
  return (
    <>
      <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} />
      <label>
        <input type="checkbox" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} />
        Show preview
      </label>
      <hr />
      {showPreview && (
        <Suspense fallback={<Loading />}>
          <h2>Preview</h2>
          <MarkdownPreview markdown={markdown} />
        </Suspense>
      )}
    </>
  );
}

// Add a fixed delay so you can see the loading state
function delayForDemo(promise) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  }).then(() => promise);
}
-------------------------------------------------------------------------------

Q4) What is Suspense?
Ans:-
-------
<Suspense> lets you display a fallback until its children have finished loading.

Syntax
----------
<Suspense fallback={<Loading />}>
  <SomeComponent />
</Suspense>

**Props 
----------
children:
The actual UI you intend to render. If children suspends while rendering, 
the Suspense boundary will switch to rendering fallback.
fallback:
An alternate UI to render in place of the actual UI if it has not finished loading. 
Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view,
such as a loading spinner or skeleton. Suspense will automatically switch to fallback when children suspends, 
and back to children when the data is ready. If fallback suspends while rendering, it will activate the closest
parent Suspense boundary.

Usage
------
Displaying a fallback while content is loading 
You can wrap any part of your application with a Suspense boundary:

-----------------------
<Suspense fallback={<Loading />}>
  <Albums />
</Suspense>
-----------------------


React will display your loading fallback until all the code and data needed by the children has been loaded.

In the example below, the Albums component suspends while fetching the list of albums. Until it‚Äôs ready to render,
 React switches the closest Suspense boundary above to show the fallback‚Äîyour Loading component. 
 Then, when the data loads, React hides the Loading fallback and renders the Albums component with data.

-----------------------------------------------
 import { Suspense } from 'react';
import Albums from './Albums.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Albums artistId={artist.id} />
      </Suspense>
    </>
  );
}

function Loading() {
  return <h2>üåÄ Loading...</h2>;
}
------------------------------------------------

Q5.) What library you have installed in your react project?
Ans:-
------------
Mui, Axios, React-router_dom, etc............

Q6.) After Fetching api url is comming and you have show the page on that url how you will do?
Ans:-
------------
We can do this with window.history.push("urlName") and it will automatically redirect to that page.

Q7.) Do you follow react new features?
Ans:-
----------
Yes we follow React latest version, they have introduced many hooks like useId, useDeferredValue etc.......

Q8.) What is env?
Ans:-
----------

Q9) What is HOC create HOC ? 
Ans :- A component that take input as a component and return comonent is known as Higher Order Component.
      e.g.:-
      ------------
      function Hoc({props}){
       return 
       <div style={{color: "red"}}>
         {props.children}
       </div>
     
      }

      function App(){
      return <Hoc><button>click</button></Hoc>
      } 

Q10) Create a custom Hook? 
Ans:- 
-------
      import { useState } from 'react';

// Custom hook for managing a counter
function useCounter(initialValue = 0, step = 1) {
  const [count, setCount] = useState(initialValue);

  const increment = () => {
    setCount(prevCount => prevCount + step);
  };

  const decrement = () => {
    setCount(prevCount => prevCount - step);
  };

  const reset = () => {
    setCount(initialValue);
  };

  return {
    count,
    increment,
    decrement,
    reset
  };
}

// Usage example
function CounterComponent() {
  const { count, increment, decrement, reset } = useCounter(0, 1);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}

Q11) what is tree shaking in react?
Ans:- Tree shaking is a technique used in modern JavaScript applications to reduce the size of the final 
bundle by eliminating unused code. In the context of React, it means removing unused modules, components, 
and functions from the final bundle that gets shipped to the browser.

How it works:
--------------
ES Modules:
Tree shaking relies heavily on the use of ES modules (import and export syntax). This syntax allows tools 
like Webpack and Rollup to analyze the dependencies between modules and identify which parts of the code are
actually used.

Static Analysis:
During the build process, the bundler analyzes the code and builds a dependency graph. It determines which 
modules are actually imported and used by your application.

Dead Code Elimination:
Once the dependency graph is built, the bundler can identify modules that are never used and remove them from
the final bundle. This process is known as "tree shaking" because it's like shaking a tree to remove the dead branches.

How to enable tree shaking in React:
------------------------------------

Use ES Modules:-
Make sure you are using the import and export syntax in your JavaScript files.

Webpack Configuration:
If you are using Webpack, ensure that you have the following settings in your webpack.config.js file:

   module.exports = {
     mode: 'production', // Tree shaking is enabled by default in production mode
     optimization: {
       usedExports: true, // Tell webpack to mark used exports
     },
   };

Babel Configuration: 
If you are using Babel, make sure you have the @babel/preset-env preset configured correctly.
This preset will transpile your ES modules to a format that the browser can understand.

   // .babelrc
   {
     "presets": [
       [
         "@babel/preset-env",
         {
           "modules": false, // Disable module transformation for tree shaking
         }
       ]
     ]
   }

Import correctly: 
Import only the specific functions or components you need from your libraries.

   // Instead of:
   import _ from 'lodash';

   // Do this:
   import debounce from 'lodash/debounce';

Benefits of tree shaking:
-------------------------
Smaller bundle size: Tree shaking can significantly reduce the size of your final bundle, which leads to faster loading times and improved performance.
Faster application startup: Smaller bundle size results in faster application startup times, providing a better user experience.
Improved maintainability: Removing unused code makes your codebase cleaner and easier to maintain.

Q12)What is reconciliation in react?
Ans:- The process by which React updates the actual DOM to match the latest state of the virtual DOM is known as reconciliation.

Why it's needed:
-----------------
Manipulating the real DOM directly is slow. React creates a virtual DOM, a lightweight copy of the real DOM in memory,
which is much faster to update. Reconciliation then figures out the minimal changes needed to update the real
DOM based on the virtual DOM.

Q13) What is diffing algorithm?
Ans:- The algorithm used by React during reconciliation to determine the differences between the old virtual DOM 
and the new virtual DOM.

How it works:
Tree diffing: React compares the two trees from the top down. If the root elements are different, the entire subtree is replaced.
Component diffing: If the root elements are the same type, React compares their props. If the props are different, the component is updated.
Element diffing: React compares the children of components. It uses keys to identify children and efficiently update them.

Key Points:
-----------

Efficiency:
The diffing algorithm is designed to be efficient, with a time complexity of O(n). This means that the time it
takes to diff grows linearly with the number of elements in the virtual DOM.

Keys:
Keys help React identify which elements in a list have changed, been added, or removed. 
This allows React to optimize list updates, avoiding unnecessary re-rendering.

Tradeoffs:
While the diffing algorithm is efficient, there are still cases where you might need to optimize further:
->Use shouldComponentUpdate to prevent unnecessary re-renders.
->Virtualize long lists to render only the visible items.

Q14)What is useImperativeHandle hook?
Ans:- useImperativeHandle is a React Hook that lets you customize the handle exposed as a ref.


egample:-
-----------
MyInput.js
------------------
import { forwardRef, useRef, useImperativeHandle } from 'react';

const MyInput = forwardRef(function MyInput(props, ref) {
  const inputRef = useRef(null);

  useImperativeHandle(ref, () => {
    return {
      focus() {
        inputRef.current.focus();
      },
      scrollIntoView() {
        inputRef.current.scrollIntoView();
      },
    };
  }, []);

  return <input {...props} ref={inputRef} />;
});

export default MyInput;

App.js
-------------
import { useRef } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const ref = useRef(null);

  function handleClick() {
    ref.current.focus();

  }

  return (
    <form>
      <MyInput placeholder="Enter your name" ref={ref} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}

Q15) What is useLayoutEffect?
Ans :- useLayoutEffect is a version of useEffect that fires before the browser repaints the screen.

Usage:-
---------
Measuring layout before the browser repaints the screen

Most components don‚Äôt need to know their position and size on the screen to decide what to render. 
They only return some JSX. Then the browser calculates their layout (position and size) and repaints the screen.

Sometimes, that‚Äôs not enough. Imagine a tooltip that appears next to some element on hover. 
If there‚Äôs enough space, the tooltip should appear above the element, but if it doesn‚Äôt fit, it should appear below.
In order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top).

To do this, you need to render in two passes:

1. Render the tooltip anywhere (even with a wrong position).
2. Measure its height and decide where to place the tooltip.
3. Render the tooltip again in the correct place.

All of this needs to happen before the browser repaints the screen. You don‚Äôt want the user to see the tooltip moving.
Call useLayoutEffect to perform the layout measurements before the browser repaints the screen:

example:-
------------
function Tooltip() {
  const ref = useRef(null);
  const [tooltipHeight, setTooltipHeight] = useState(0); // You don't know real height yet

  useLayoutEffect(() => {
    const { height } = ref.current.getBoundingClientRect();
    setTooltipHeight(height); // Re-render now that you know the real height
  }, []);

  // ...For Rest implementation visit React Official Website.
}

Q16) What is useTransition Hook?
Ans :- useTransition is a React Hook that lets you update the state without blocking the UI.

syntax:-
------------
const [isPending, startTransition] = useTransition()
useTransition returns an array with exactly two items:

1) The isPending flag that tells you whether there is a pending Transition.
2) The startTransition function that lets you mark a state update as a Transition.

Usage
1) Marking a state update as a non-blocking Transition
2) Updating the parent component in a Transition
3) Displaying a pending visual state during the Transition
4) Preventing unwanted loading indicators
5) Building a Suspense-enabled router
6) Displaying an error to users with an error boundary



Q17) How React behave is it asynchronous or synchronous ? 
Ans:- React updates are asynchronous by default. When you call setState (or a similar state update function from hooks like useState), 
React schedules the update to be applied later, during the next render cycle. This means that the state isn't updated immediately after 
calling setState. Instead, React batches multiple updates and re-renders the component efficiently to avoid unnecessary updates.

example:-
----------
const [count, setCount] = useState(0);

function handleClick() {
  console.log(count); // Will log the value before update
  setCount(count + 1);
  console.log(count); // Will still log the old value (due to async update)
}

In the above code, count will not be immediately updated after calling setCount. It will update after the next render,
so you'll see the old value in the console.

Q18) What is rendere in react js?
Ans:- In React, a renderer is responsible for taking the component tree and translating it into the user interface.
 This process involves several key aspects:

 1. Initial Rendering:
When a React application starts, it performs an initial render. This is the first time the component tree is converted into UI elements.
The root component is rendered, and React recursively renders all its child components.
2. Component Rendering:
React components, whether functional or class-based, have a render method (or the function body for functional components).
This method returns JSX, which describes the desired UI structure.
React converts JSX into React elements, which are plain JavaScript objects representing the UI.
3. Virtual DOM:
React maintains a virtual representation of the DOM, known as the Virtual DOM.
After rendering, React compares the new Virtual DOM with the previous one.
This comparison, called reconciliation, identifies the minimal set of changes needed to update the actual DOM.
4. Re-rendering:
When a component's state or props change, React triggers a re-render.
The component's render method is called again to generate a new Virtual DOM.
React then reconciles this new Virtual DOM with the previous one and updates the actual DOM efficiently.
5. Commit Phase: 
After reconciliation, React applies the calculated changes to the actual DOM.
This commit phase updates the user interface, making the changes visible.
6. Custom Renderers:
Besides the default DOM renderer, React allows custom renderers.
These renderers can target different platforms, such as React Native for mobile apps or custom rendering for specific environments.
7. Test Renderer: 
The react-test-renderer library enables rendering React components to pure JavaScript objects without using the DOM.
This is useful for testing components in a Node.js environment or for generating snapshots of the UI.
Key Concepts:
JSX: A syntax extension to JavaScript that allows writing HTML-like code within JavaScript.
React Elements: JavaScript objects that represent UI elements.
Virtual DOM: An in-memory representation of the actual DOM, used for efficient updates.
Reconciliation: The process of comparing the current and new Virtual DOM to identify changes.
Commit: The phase where React applies changes to the actual DOM.
In summary, the renderer in React is a core mechanism that translates component descriptions 
into the user interface, optimizing the process for efficiency and performance.

-> In React, the term "renderer" can mean a few different things depending on the context
1. ReactDOM Renderer (Default)
When you create a web app with React, you're usually using the React DOM renderer, which renders components to the browser DOM.
example:
------------------
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

This is the standard renderer for web apps.

2.Custom Render Functions (Render Props / Render Methods)
In component design, a "renderer" might refer to a render prop:
example
------------------
const List = ({ items, renderItem }) => (
  <ul>
    {items.map((item, index) => (
      <li key={index}>{renderItem(item)}</li>
    ))}
  </ul>
);

// Usage:
<List items={[1, 2, 3]} renderItem={item => <strong>{item}</strong>} />
This pattern allows you to pass a custom renderer function to a component.

3. Renderer in React Testing
When testing components with libraries like React Testing Library, you use a render() function:
example
---------------------
import { render, screen } from '@testing-library/react';
import MyComponent from './MyComponent';

test('renders text', () => {
  render(<MyComponent />);
  expect(screen.getByText('Hello')).toBeInTheDocument();
});


Q19) What is two way data binding and one way data binding in react js? 
Ans:- Data binding in React refers to the synchronization of data between the UI and the application state.
 React primarily utilizes a one-way data binding approach, but it can also achieve two-way data binding through specific techniques. 

 1. Two-way data binding
 ---------------------------------
Two-way data binding in React is a technique that synchronizes the UI with the component's state. 
It allows changes in the UI to automatically update the state and vice versa. 
React primarily uses one-way data flow, where data flows from parent components to child components via props.
 However, React supports two-way data binding through controlled components, especially with form elements like input,
  textarea, and select. 
In a controlled component, the input's value is bound to a piece of state. 
Changes to the input trigger an event handler that updates the state, which then re-renders 
the component with the new value. This creates a bidirectional flow where changes in the UI 
update the state, and changes in the state update the UI. 

egample
-------------------------------------
import React, { useState } from 'react';

function MyForm() {
  const [inputValue, setInputValue] = useState('');

  const handleChange = (event) => {
    setInputValue(event.target.value);
  };

  return (
    <input
      type="text"
      value={inputValue}
      onChange={handleChange}
    />
  );
}

export default MyForm;

In this example, the input's value is controlled by the inputValue state. The handleChange function updates the state whenever the input value changes.
 This creates a two-way binding effect, ensuring the input field and the state are always in sync.

 2. One-way data binding
 ------------------------------------
->Data flows in a single direction, typically from parent components to child components via props. 
->Child components cannot directly modify the props they receive; they are read-only.
->Changes in the application state trigger updates in the UI.
->This approach makes data flow predictable and easier to manage and debug. 

example
-------------
function Welcome(props) {
	return <h1>Hello, {props.name}! </h1>;
}
function App() {
	return <Welcome name="John" />;
}

Q20) what is Atomic design pattern in react ?
Ans-> Atomic Design is a methodology for creating design systems that promotes modularity,
scalability, and maintainability of user interfaces. It breaks down interfaces into fundamental 
building blocks, inspired by chemistry. Here's how it applies to React.

a) Atoms:
  -> The smallest, indivisible components.
  -> Examples in React: buttons, input fields, icons, labels, and typogrphy.
  -> Created as functional or class components with minimal logic.

b) Molecules:
  -> Combinations of atoms working together.
  -> Examples: a search bar (input + button), a card (image + text + button), or a form field (label + input)
  -> These are reusable and can have their own properties and functionalities.

c) Organisms:
  -> Groups of molecules and/or atoms forming a distinct section of an interface.
  -> Examples: a navigation bar, a header, a sidebar, a card list.
  -> They represent more complex UI component.

d) Templates: 
  -> Full-page layouts composed of organisms.
  -> Define the overall structure of page but lack specific content.
  -> They act as wireframes, showing the arrangement of components.

e) Pages:
  -> Specific instances of templates with real content.
  -> Where components are populated with data and connected to the applications's functionality.
  -> This is where the final UI is rendered.

Benefits of using Atomic Design in React and AI:

Component Reusability:
  Pre-designed components can be shared across different projects, saving time and effort.
Consistent Design System:
  Ensures a unified look and feel across applications, improving the user experience.
Maintainability:
  Easier to update and maintain code as individual components are modular and decoupled.
Scalability:
  Suitable for building large-scale applications with complex UIs.
Team Collaboration:
  Clear structure promotes teamwork and reduces conflicts when building components.
Readability:
  Clear component hierarchy makes the codebase easier to understand.
Prototyping:
  Facilitates faster prototyping and building new views by reusing existing UI building blocks. 


Q21 ) Facade design pattern in react?
Ans:- The Facade Design Pattern is a structural pattern that provides a simplified interface 
to a more complex system or set of subsystems. In React, this can be useful to encapsulate 
complex logic, third-party libraries, or multiple state interactions behind a clean and simple API.

üß† When to Use the Facade Pattern in React
Wrapping complex business logic into a simple interface.

Hiding multiple service or API calls.

Simplifying state management interactions.

Wrapping third-party libraries (like Stripe, Firebase, etc.).

‚úÖ Example: Using Facade Pattern in React
Scenario:
You want to manage authentication logic (login, logout, user session) using Firebase, 
but want your components to deal with a simple API.

Example
-------------
// services/AuthFacade.ts
import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "firebase/auth";
import { app } from "./firebase"; // assume Firebase is initialized in this file

const auth = getAuth(app);

export const AuthFacade = {
  login: async (email: string, password: string) => {
    const userCredential = await signInWithEmailAndPassword(auth, email, password);
    return userCredential.user;
  },

  logout: async () => {
    await signOut(auth);
  },

  subscribeToAuthChanges: (callback: (user: any) => void) => {
    return onAuthStateChanged(auth, callback);
  },

  getCurrentUser: () => {
    return auth.currentUser;
  }
};

üë®‚Äçüíª Step 2: Use in a React Component

// components/LoginForm.tsx
import { useState } from "react";
import { AuthFacade } from "../services/AuthFacade";

export default function LoginForm() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  const handleLogin = async () => {
    try {
      await AuthFacade.login(email, password);
      alert("Logged in!");
    } catch (err: any) {
      setError(err.message);
    }
  };

  return (
    <div>
      <input value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" />
      <input value={password} onChange={e => setPassword(e.target.value)} type="password" placeholder="Password" />
      <button onClick={handleLogin}>Login</button>
      {error && <p style={{ color: "red" }}>{error}</p>}
    </div>
  );
}

Q22) Security Machanism in React js?
Ans:- 
  React does not have many built-in security mechanisms beyond basic Cross-Site Scripting (XSS) protection, as it is a front-end library. The primary responsibility for robust security lies with the developer's implementation of best practices and secure backend systems. 

Key security mechanisms and best practices in React include:

Core React Mechanisms (XSS Prevention)
--Automatic Escaping: By default, React escapes any values embedded in JSX with curly braces ({}) before rendering them in the DOM. This ensures that injected data is treated as plain text and not executed as HTML or JavaScript, effectively preventing most XSS attacks.

-Do: <div>{data}</div>
-Don't: this.myRef.current.innerHTML = userControlledValue

dangerouslySetInnerHTML Caution: The dangerouslySetInnerHTML prop allows direct insertion of raw HTML, bypassing React's automatic escaping mechanism.

Best Practice: Only use this prop when absolutely necessary and always sanitize the content beforehand using a library like DOMPurify. 
General Security Best Practices

--Input Validation & Sanitization: Validate and sanitize all user input on both the client and server sides to prevent injection attacks (XSS, SQL injection). Use validation libraries like Yup or HTML attributes (e.g., required, pattern) for client-side validation.

--Secure APIs: Since React is client-side, the backend APIs must be secure. Use prepared statements or ORM libraries to prevent SQL injection and use secure authentication methods like OAuth or JWT with server-side validation.

--Content Security Policy (CSP): Implement a strict CSP to control which scripts and resources the browser is allowed to load. This acts as a defense-in-depth layer against XSS, blocking unauthorized script execution. Use libraries like React Helmet to manage security headers.

--Secure Authentication & Authorization: Implement robust mechanisms such as multi-factor authentication (MFA), secure session management using HttpOnly cookies, and Role-Based Access Control (RBAC).

--HTTPS Only: Ensure all communication between the client and the server uses HTTPS/TLS to encrypt data in transit, protecting sensitive information from interception (Man-in-the-Middle attacks).

--Dependency Management: Regularly update React and its third-party dependencies to benefit from security patches. Use tools like npm audit or Snyk to scan for known vulnerabilities.

--Avoid Direct DOM Access: Rely on React's state management and virtual DOM for updates. Avoid using refs or findDomNode() to directly manipulate the DOM with user-controlled input, which can lead to XSS.

--Error Handling and Logging: Ensure error messages do not expose sensitive application or server information.

--Avoid JSON Injection Attacks: When using server-side rendering to preload state, escape HTML-sensitive characters (like <) from JSON data to prevent script injection. 

Q13) Responsive design in React?
Ans:- 
Responsive Design in React üì±üíª
Responsive Design means building UI that adapts automatically to different screen sizes (mobile, tablet, desktop).
In React, responsiveness is mainly handled using CSS, JavaScript hooks, and UI libraries.

a) CSS Media Queries (Most Common) üéØ
Used directly in CSS or styled-components.
-----------------------------------
.card {
  width: 100%;
}

@media (min-width: 768px) {
  .card {
    width: 50%;
  }
}

@media (min-width: 1024px) {
  .card {
    width: 33%;
  }
}
-------------------------------------

b) Flexbox & CSS Grid (Core of Responsive Layouts) üß±

Flexbox Example
---------------------------------------
.container {
  display: flex;
  flex-wrap: wrap;
}

.card {
  flex: 1 1 100%;
}

@media (min-width: 768px) {
  .card {
    flex: 1 1 50%;
  }
}
---------------------------------------

CSS Grid Example
---------------------------------------
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}
---------------------------------------

c) Responsive Images üñºÔ∏è
--------------------------------------
<img
  src="small.jpg"
  srcSet="small.jpg 480w, medium.jpg 768w, large.jpg 1200w"
  sizes="(max-width: 768px) 100vw, 50vw"
  alt="example"
/>
-------------------------------------

d)Responsive Typography üìñ
--------------------------------
html {
  font-size: clamp(14px, 2vw, 18px);
}
---------------------------------

e) Using Tailwind CSS ‚ö°

f) UI Libraries with Built-in Responsiveness üß©

-Material UI (useMediaQuery, Grid)
-Ant Design
-Chakra UI

g) Handling Navigation Responsively üçî
---------------------------------------
{isMobile ? <HamburgerMenu /> : <Navbar />}
--------------------------------------

h) Use em and rem 
-------------------------------

em-> em is relative to the font-size of its parent element
rem-> rem is relative to the font-size of the root element (<html/>).

em (Parent-relative unit):-
-----------------------------------------------------------------------------------------------------------
The em unit provides modular scaling, where an element's size depends on its immediate context. 

Reference Point: The font-size of the nearest parent element. If used on a property other than font-size itself (like padding or margin), it refers to the element's own calculated font-size. 

Behavior: Sizing can compound in nested elements. For example, if a parent has font-size: 20px, and a child has font-size: 1.5em, the child's text will be 30px (1.5*20px). If that child has a nested element with font-size: 1.5em, it will be 45px (1.5*30px). 

Best Used For: Components that need to scale proportionally within their container, such as buttons, icons, or specific widgets where internal spacing should relate to the component's text size.


rem (Root-relative unit):-
-------------------------------------------------------------------------------------------------------------
The rem unit provides consistent scaling across the entire document, regardless of where an element is nested. 

Reference Point: Always the font-size of the <html> element. The browser default is typically 16px, meaning 1rem equals 16px unless you specify otherwise in your CSS. 

Behavior: Sizes do not compound with nesting. If the root is 16px, a child element with font-size: 2rem will always be 32px, no matter how many parent elements it is nested within. 

Best Used For: Global typography, margins, padding, and consistent layout spacing, ensuring that all elements scale uniformly when the user adjusts their browser's default font size for accessibility