Q1) What is asynchronous?
Ans:-
--------
Asynchronous programming is a technique that enables your program to start a potentially long-running task and still be able to be
responsive to other events while that task runs, rather than having to wait until that task has finished. Once that task has finished, 
your program is presented with the result.

Many functions provided by browsers, especially the most interesting ones, can potentially take a long time, and therefore, 
are asynchronous. For example:

==>Making HTTP requests using fetch()
==>Accessing a user's camera or microphone using getUserMedia()
==>Asking a user to select files using showOpenFilePicker()

So even though you may not have to implement your own asynchronous functions very often, you are very likely to need to use them correctly.

lets understand by code
-------------------------------
function makeGreeting(name) {
  return `Hello, my name is ${name}!`;
}

const name = "Miriam";
const greeting = makeGreeting(name);
console.log(greeting);
-----------------------------

We should note here that the browser effectively steps through the program one line at a time, in the order we wrote it. 
At each point, the browser waits for the line to finish its work before going on to the next line. It has to do this because
each line depends on the work done in the preceding lines.
That makes this a synchronous program. It would still be synchronous even if we called a separate function.
Here, makeGreeting() is a synchronous function because the caller has to wait for the function to finish its work and return a
value before the caller can continue.

**PROBLEM WITH SYNCHRONOUS FUNCTION 
---------------------------------
  What if the synchronous function takes a long time?
  for example lets say you have created a page where have many html tags like text, button etc. and suppose you have created a text box where
  you type number and after typing you are pressing a button. on button click it will generate prime number and display that number. if you have 
  type large number and it it taking suppose 1 minute of time to execute it and till one minute will not complete you can't perform any
  operation in your web page, means your page become unresponsive.

  What we need is a way for our program to:
  ------------------------------------------
  ==>Start a long-running operation by calling a function.
  ==>Have that function start the operation and return immediately, so that our program can still be responsive to other events.
  ==>Have the function execute the operation in a way that does not block the main thread, for example by starting a new thread.
  ==>Notify us with the result of the operation when it eventually completes.

Q2) What is callback and callback hell?
  Ans:-
  -------
  An event handler is a particular type of callback. A callback is just a function that's passed into another function,
  with the expectation that the callback will be called at the appropriate time. As we just saw, callbacks used to be 
  the main way asynchronous functions were implemented in JavaScript.

  However, callback-based code can get hard to understand when the callback itself has to call functions that accept a callback.
  This is a common situation if you need to perform some operation that breaks down into a series of asynchronous functions. 
  For example, consider the following:
-------------------------------------
function doStep1(init) {
  return init + 1;
}

function doStep2(init) {
  return init + 2;
}

function doStep3(init) {
  return init + 3;
}

function doOperation() {
  let result = 0;
  result = doStep1(result);
  result = doStep2(result);
  result = doStep3(result);
  console.log(`result: ${result}`);
}

doOperation();
----------------------------------

Here we have a single operation that's split into three steps, where each step depends on the last step. In our example, 
the first step adds 1 to the input, the second adds 2, and the third adds 3. Starting with an input of 0, the end result is 6 (0 + 1 + 2 + 3).
As a synchronous program, this is very straightforward. But what if we implemented the steps using callbacks?

----------------------------------------------
function doStep1(init, callback) {
  const result = init + 1;
  callback(result);
}

function doStep2(init, callback) {
  const result = init + 2;
  callback(result);
}

function doStep3(init, callback) {
  const result = init + 3;
  callback(result);
}

function doOperation() {
  doStep1(0, (result1) => {
    doStep2(result1, (result2) => {
      doStep3(result2, (result3) => {
        console.log(`result: ${result3}`);
      });
    });
  });
}

doOperation();
--------------------------------------------
Because we have to call callbacks inside callbacks, we get a deeply nested doOperation() function, which is much 
harder to read and debug. This is sometimes called "callback hell" or the "pyramid of doom" (because the indentation
looks like a pyramid on its side).When we nest callbacks like this, it can also get very hard to handle errors: often you have 
to handle errors at each level of the "pyramid", instead of having error handling only once at the top level.
For these reasons, most modern asynchronous APIs don't use callbacks. Instead, the foundation of asynchronous programming in 
JavaScript is the Promise.

Q3) What is promises in js?
Ans:- 
--------
The Promise is an object represents the eventual completion (or failure) 
of an asynchronous operation and its resulting value.

This lets asynchronous methods return values like synchronous methods: 
instead of immediately returning the final value,
the asynchronous method returns a promise to supply the value at some point in the future.

A Promise is in one of these states:
---------------------------------------
    a) pending: initial state, neither fulfilled nor rejected.
    b) fulfilled: meaning that the operation was completed successfully.
    c) rejected: meaning that the operation failed.

CHAINED promises
-----------------
The methods Promise.prototype.then(), Promise.prototype.catch(),
and Promise.prototype.finally() are used to associate further action with a promise
that becomes settled. As these methods return promises, they can be chained.

The .then() method takes up to two arguments; the first argument is a callback function
for the fulfilled case of the promise, and the second argument is a callback function
for the rejected case. Each .then() returns a newly generated promise object, which 
can optionally be used for chaining; for example:

const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("foo");
  }, 300);
});

myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC);


PROMISE methods
----------------
Promise.all(), Promise.allSettled(), Promise.any(), Promise.race(),
Promise.prototype.catch(), Promise.prototype.finally(), Promise.prototype.then()
, Promise.resolve(),Promise.reject(), Promise.withResolvers()

2.) What is event Loop ?
Ans:-
--------
JavaScript has a runtime model based on an event loop, which is responsible 
for executing the code, collecting and processing events, and executing queued 
sub-tasks.
The event loop allows programs to be responsive to user input and handle concurrent operations
without blocking the entire application.
For example, in a web browser, the event loop is responsible for handling user interactions, 
network requests, and other asynchronous tasks while ensuring the responsiveness of the user 
interface. In server-side applications, an event loop might be used to manage multiple incoming requests concurrently.

Generally We can understand the event loop in three data storage type a) stack b) heap c) queue

***STACK
-------------------

        Function calls form a stack of frames
        ---------------------------------------------------
        function foo(b) {
          const a = 10;
          return a + b + 11;
        }

        function bar(x) {
          const y = 3;
          return foo(x * y);
        }

        const baz = bar(7); // assigns 42 to baz
        ----------------------------------------------------

        Order of operations:
        ------------------------
        a) When calling bar, a first frame is created containing references to bar's arguments and local variables.
        b) When bar calls foo, a second frame is created and pushed on top of the first one, 
           containing references to foo's arguments and local variables.
        c) When foo returns, the top frame element is popped out of the stack (leaving only bar's call frame).
        d) When bar returns, the stack is empty.
           Note that the arguments and local variables may continue to exist, as they are stored outside
           the stack â€” so they can be accessed by any nested functions long after their outer function has returned.

***HEAP
------------------
        Objects are allocated in a heap which is just a name to denote a large (mostly unstructured) region of memory.

***QUEUE 
------------------
        A JavaScript runtime uses a message queue, which is a list of messages to be processed. Each message has an 
        associated function that gets called to handle the message.
        At some point during the event loop, the runtime starts handling the messages on the queue, starting with 
        the oldest one. To do so, the message is removed from the queue and its corresponding function is called 
        with the message as an input parameter. As always, calling a function creates a new stack frame for that 
        function's use.

        The processing of functions continues until the stack is once again empty. Then, the event loop
        will process the next message in the queue (if there is one).


NEVER BLOCKING 
---------------
        A very interesting property of the event loop model is that JavaScript, unlike a lot of other languages,
        never blocks. Handling I/O is typically performed via events and callbacks, so when the application is 
        waiting for an DB query to return or a fetch() request to return, it can still process other things
        like user input.


Q3) Print Second most occuring element in array?
Ans:-
-------------------------------------------
const arr = [2,2,2,5,5,1,1,1,1,8,8,9];
const obj = {};

//create count of occuring of element in key value pair
arr.forEach(element => {
   obj[element] = (obj[element] || 0)+1
});

//convert object in array and sort according to thair value
//for sorting we have used sort method that sort with comparator

let sortedArr = Object.entries(obj).sort((a, b)=> b[1] - a[1]);

if(sortedArr.length >= 2){
   console.log(sortedArr[1][0]);
}
-------------------------------------------

Q4) 


