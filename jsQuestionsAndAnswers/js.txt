Q1) What is asynchronous?
Ans:-
--------
Asynchronous programming is a technique that enables your program to start a potentially long-running task and 
still be able to beresponsive to other events while that task runs, rather than having to wait until that task 
has finished. Once that task has finished, your program is presented with the result.

Many functions provided by browsers, especially the most interesting ones, can potentially take a long time,
and therefore, are asynchronous. For example:

==>Making HTTP requests using fetch()
==>Accessing a user's camera or microphone using getUserMedia()
==>Asking a user to select files using showOpenFilePicker()

So even though you may not have to implement your own asynchronous functions very often, you are very likely
 to need to use them correctly.

lets understand by code
-------------------------------
function makeGreeting(name) {
  return `Hello, my name is ${name}!`;
}

const name = "Miriam";
const greeting = makeGreeting(name);
console.log(greeting);
-----------------------------

We should note here that the browser effectively steps through the program one line at a time, in the order we wrote it. 
At each point, the browser waits for the line to finish its work before going on to the next line. It has to do this because
each line depends on the work done in the preceding lines.
That makes this a synchronous program. It would still be synchronous even if we called a separate function.
Here, makeGreeting() is a synchronous function because the caller has to wait for the function to finish its work and return a
value before the caller can continue.

**PROBLEM WITH SYNCHRONOUS FUNCTION 
---------------------------------
  What if the synchronous function takes a long time?
  for example lets say you have created a page where have many html tags like text, button etc. and suppose you have created a text box where
  you type number and after typing you are pressing a button. on button click it will generate prime number and display that number. if you have 
  type large number and if it taking suppose 1 minute of time to execute it and till one minute will not complete you can't perform any
  operation in your web page, means your page become unresponsive.

  What we need is a way for our program to:
  ------------------------------------------
  ==>Start a long-running operation by calling a function.
  ==>Have that function start the operation and return immediately, so that our program can still be responsive to other events.
  ==>Have the function execute the operation in a way that does not block the main thread, for example by starting a new thread.
  ==>Notify us with the result of the operation when it eventually completes.

Q2) What is callback and callback hell?
  Ans:-
  -------
  An event handler is a particular type of callback. A callback is just a function that's passed into another function,
  with the expectation that the callback will be called at the appropriate time. As we just saw, callbacks used to be 
  the main way asynchronous functions were implemented in JavaScript.

  However, callback-based code can get hard to understand when the callback itself has to call functions that accept a callback.
  This is a common situation if you need to perform some operation that breaks down into a series of asynchronous functions. 
  For example, consider the following:
-------------------------------------
function doStep1(init) {
  return init + 1;
}

function doStep2(init) {
  return init + 2;
}

function doStep3(init) {
  return init + 3;
}

function doOperation() {
  let result = 0;
  result = doStep1(result);
  result = doStep2(result);
  result = doStep3(result);
  console.log(`result: ${result}`);
}

doOperation();
----------------------------------

Here we have a single operation that's split into three steps, where each step depends on the last step. In our example, 
the first step adds 1 to the input, the second adds 2, and the third adds 3. Starting with an input of 0, the end result is 6 (0 + 1 + 2 + 3).
As a synchronous program, this is very straightforward. But what if we implemented the steps using callbacks?

----------------------------------------------
const readline = require("readline");
const fs = require("fs");

fs.readFile('./Files/start.txt', 'utf-8', (err, data)=>{
         console.log(data);
        fs.readFile(`./Files/${data}.txt`,'utf-8', (err2, data2)=>{
            console.log(data2)
             fs.readFile(`./Files/append.txt`, 'utf-8',(err3, dat3)=>{
                console.log(dat3)
                fs.writeFile('./Files/output.txt', `${data2}\n\n${dat3}\n\n date created ${new Date()}`, (err4, data4)=>{
                    
                });
             })
        });
})

--------------------------------------------
Because we have to call callbacks inside callbacks, we get a deeply nested doOperation() function, which is much 
harder to read and debug. This is sometimes called "callback hell" or the "pyramid of doom" (because the indentation
looks like a pyramid on its side).When we nest callbacks like this, it can also get very hard to handle errors: often you have 
to handle errors at each level of the "pyramid", instead of having error handling only once at the top level.
For these reasons, most modern asynchronous APIs don't use callbacks. Instead, the foundation of asynchronous programming in 
JavaScript is the Promise.

Q3) What is promises in js?
Ans:- 
--------
The Promise is an object represents the eventual completion (or failure) 
of an asynchronous operation and its resulting value.

This lets asynchronous methods return values like synchronous methods: 
instead of immediately returning the final value,
the asynchronous method returns a promise to supply the value at some point in the future.

A Promise is in one of these states:
---------------------------------------
    a) pending: initial state, neither fulfilled nor rejected.
    b) fulfilled: meaning that the operation was completed successfully.
    c) rejected: meaning that the operation failed.

CHAINED promises
-----------------
The methods Promise.prototype.then(), Promise.prototype.catch(),
and Promise.prototype.finally() are used to associate further action with a promise
that becomes settled. As these methods return promises, they can be chained.

The .then() method takes up to two arguments; the first argument is a callback function
for the fulfilled case of the promise, and the second argument is a callback function
for the rejected case. Each .then() returns a newly generated promise object, which 
can optionally be used for chaining; for example:

const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("foo");
  }, 300);
});

myPromise
  .then(handleFulfilledA, handleRejectedA)
  .then(handleFulfilledB, handleRejectedB)
  .then(handleFulfilledC, handleRejectedC);


PROMISE methods
----------------
Promise.all(), Promise.allSettled(), Promise.any(), Promise.race(),
Promise.prototype.catch(), Promise.prototype.finally(), Promise.prototype.then()
, Promise.resolve(),Promise.reject(), Promise.withResolvers()

4.) What is event Loop ?
Ans:-
--------
JavaScript has a runtime model based on an event loop, which is responsible 
for executing the code, collecting and processing events, and executing queued 
sub-tasks.
The event loop allows programs to be responsive to user input and handle concurrent operations
without blocking the entire application.
For example, in a web browser, the event loop is responsible for handling user interactions, 
network requests, and other asynchronous tasks while ensuring the responsiveness of the user 
interface. In server-side applications, an event loop might be used to manage multiple incoming requests concurrently.

Generally We can understand the event loop in three data storage type a) stack b) heap c) queue

***STACK
-------------------

        Function calls form a stack of frames
        ---------------------------------------------------
        function foo(b) {
          const a = 10;
          return a + b + 11;
        }

        function bar(x) {
          const y = 3;
          return foo(x * y);
        }

        const baz = bar(7); // assigns 42 to baz
        ----------------------------------------------------

        Order of operations:
        ------------------------
        a) When calling bar, a first frame is created containing references to bar's arguments and local variables.
        b) When bar calls foo, a second frame is created and pushed on top of the first one, 
           containing references to foo's arguments and local variables.
        c) When foo returns, the top frame element is popped out of the stack (leaving only bar's call frame).
        d) When bar returns, the stack is empty.
           Note that the arguments and local variables may continue to exist, as they are stored outside
           the stack â€” so they can be accessed by any nested functions long after their outer function has returned.

***HEAP
------------------
        Objects are allocated in a heap which is just a name to denote a large (mostly unstructured) region of memory.

***QUEUE 
------------------
        A JavaScript runtime uses a message queue, which is a list of messages to be processed. Each message has an 
        associated function that gets called to handle the message.
        At some point during the event loop, the runtime starts handling the messages on the queue, starting with 
        the oldest one. To do so, the message is removed from the queue and its corresponding function is called 
        with the message as an input parameter. As always, calling a function creates a new stack frame for that 
        function's use.

        The processing of functions continues until the stack is once again empty. Then, the event loop
        will process the next message in the queue (if there is one).


NEVER BLOCKING 
---------------
        A very interesting property of the event loop model is that JavaScript, unlike a lot of other languages,
        never blocks. Handling I/O is typically performed via events and callbacks, so when the application is 
        waiting for an DB query to return or a fetch() request to return, it can still process other things
        like user input.

Q5) Diffrence between map, filter, forEach ?
ans:- 
Array.prototype.map
-------------------
        This function creates a new array and return entire array.
        
        e.g:- const array1 = [1, 4, 9, 16];

        // Pass a function to map
        const map1 = array1.map((x) => x * 2);
        console.log(map1);
        // Expected output: Array [2, 8, 18, 32]

Array.prototype.filter 
----------------------
        The filter() method of Array instances creates a shallow copy of 
a portion of a given array, filtered down to just the elements from the given
array that pass the test implemented by the provided function and return a new array 

        eg:-
        const words = ['spray', 'elite', 'exuberant', 'destruction', 'present'];

        const result = words.filter((word) => word.length > 6);

        console.log(result);
        // Expected output: Array ["exuberant", "destruction", "present"]

Array.prototype.forEach 
---------------------- 
        The forEach() method of Array instances executes a provided function once for each array element,
and it never returns array. 

const array1 = ['a', 'b', 'c'];

array1.forEach((element) => console.log(element));

// Expected output: "a"
// Expected output: "b"
// Expected output: "c"


Q6) Diffrence between Promise.all and Promise.allSettled ? 
Ans:- 
---------
Promise.all()
-----------------
The Promise.all() method takes an iterable of promises as an input, and returns a 
single Promise that resolves to an array of the results of the input promises.
Promise.all is rejected if at least one of the elements are rejected. For example, 
we pass 2 promises that resolve and one promise that rejects immediately, 
then Promise.all will reject immediately.
----------------------------------------

const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise((resolve, reject) => {
  setTimeout(reject, 100, 'foo');
});

Promise.all([promise1, promise2, promise3]).then((values) => {
  console.log(values);
}).catch((err)=>{
 console.log(err);
})

//output "foo"

Promise.allSettled()
--------------------
     It returns a promise that always resolves after all of the given promises
have either fulfilled or rejected, with an array of objects that each describes
the outcome of each promise.
The value (or reason) reflects what value each promise was fulfilled (or rejected) with.
if success then it will give {status : "fulfilled",value : val}
if rejected then it will give {status : "rejected", reason : val} 

----------------------------------------------
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise((resolve, reject) => {
  setTimeout(reject, 100, 'foo');
});

Promise.allSettled([promise1, promise2, promise3]).then((values) => {
  console.log(values);
}).catch((err)=>{
 console.log(err);
})
// Expected output:
[{
  status: "fulfilled",
  value: 3
}, {
  status: "fulfilled",
  value: 42
}, {
  reason: "foo",
  status: "rejected"
}]




Q7) Print Second most occuring element in array?
Ans:-
-------------------------------------------
const arr = [2,2,2,5,5,1,1,1,1,8,8,9];
const obj = {};

//create count of occuring of element in key value pair
arr.forEach(element => {
   obj[element] = (obj[element] || 0)+1
});

//convert object in array and sort according to thair value
//for sorting we have used sort method that sort with comparator

let sortedArr = Object.entries(obj).sort((a, b)=> b[1] - a[1]);

if(sortedArr.length >= 2){
   console.log(sortedArr[1][0]);
}
-------------------------------------------

Q8) function composition questions
Given an array of functions [f1, f2, f3, ..., fn], return a new function fn that is the function composition of the array of functions.
The function composition of [f(x), g(x), h(x)] is fn(x) = f(g(h(x))).
The function composition of an empty list of functions is the identity function f(x) = x.
You may assume each function in the array accepts one integer as input and returns one integer as output. 

Example 1:
Input: functions = [x => x + 1, x => x * x, x => 2 * x], x = 4
Output: 65
Explanation:
Evaluating from right to left ...
Starting with x = 4.
2 * (4) = 8
(8) * (8) = 64
(64) + 1 = 65
-----------------------------------
Ans:-
-------
var compose = function(functions) {
    return function(x) {
        for(let i = functions.length - 1;i >= 0;i--){
           x = functions[i](x);
        }
        return x;
    }
};

  const fn = compose([x => x + 1, x => 2 * x])
  fn(4) 
 ----------------------------------

 Q9) Add all the elements in single array, without using inbuilt function? 
 const arr = [1,2, [3,4, [5,6]], 7, 8, [9,10]];

 Ans:= 
  const res = [];

      for(let i = 0;i<arr.length;i++){
          if(Array.isArray(arr[i])){
             addElem(arr[i]);
          }else{
            res.push(arr[i]);
          }
      }

      function addElem(newArr){
         for(let i = 0;i<newArr.length;i++){
            if(Array.isArray(newArr[i])){
              addElem(newArr[i]);
            }else{
              res.push(newArr[i]);
            }
         }
      }

      console.log(res);

Q10) Given an array sum the number located in even position using advance technique don't use loop?
Ans:- 
-------

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const sumOfEvenNumbers = numbers.reduce((sum, number, index) => {
    if (index % 2 !== 0) {
        return sum + number;
    }
    return sum;
}, 0);

console.log(sumOfEvenNumbers); // Output: 30

if you will remove initial value from second parameter from reduce function then it will take array's first value as initial value.

Q11) what will be the output of the code.
console.log("anand")

setTimeout(() => {
  console.log("timer")
}, 100)
new Promise((res, rej) => {
  console.log("promise")
  rej()
})
  .then(() => {
    console.log("first")
  })
  .catch(() => {
    console.log("second")
  })
  .then(() => {
    console.log("third")
  })

console.log("raj")

ans:=
"anand"
"promise"
"raj"
"second"
"third"
"timer"

Q12)  How Object.freeze() works under the hood?
Ans:- check below article link for best Explanation
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty

example:-
-----------------------------
function simpleFreeze(obj) {
  // Prevent adding new properties
  Object.preventExtensions(obj);

  // Get all properties and make them non-writable and non-configurable
  Object.getOwnPropertyNames(obj).forEach(prop => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    
    if (descriptor.configurable) {
      Object.defineProperty(obj, prop, {
        writable: false,
        configurable: false
      });
    }
  });

  return obj;
}

const obj = {
 name : "anand",
 age : "25"
}

simpleFreeze(obj);

 obj.name = "raj"
 
 console.log(obj);


 in simple words you can do via Object.defineProperty(obj, pro, {
  writable: false,
  configurable : false
 })
 for Preventing changes, but you can do more changes or add properties for doing this.

 Q13) What is index db.
 Ans:- IndexedDB is a built-in browser database that lets you store large amounts of structured data,
       including files/blobs, in the user's browser.

Key Features of IndexedDB:
---------------------------------------
-> Client-side: Data is stored in the user's browser.

-> Asynchronous: Operations are non-blocking (via events or Promises).

-> Key-value store: Data is stored as key-value pairs.

-> Structured storage: You can store JavaScript objects directly.

-> Works offline: Great for offline-first web apps.

 Use Cases
 ------------
-> Offline data storage (e.g., forms, product catalogs)

-> Caching API responses

-> Local storage for PWAs (Progressive Web Apps)

-> Storing files/blobs like images

example 
---------------------

// Open or create a database
const request = indexedDB.open("MyDB", 1);

request.onupgradeneeded = function (event) {
  const db = event.target.result;
  db.createObjectStore("users", { keyPath: "id" });
};

request.onsuccess = function (event) {
  const db = event.target.result;

  const tx = db.transaction("users", "readwrite");
  const store = tx.objectStore("users");

  store.put({ id: 1, name: "Alice" });

  tx.oncomplete = () => console.log("Data saved");
};


Q14) what is web worker? 
Ans:- A Web Worker is a feature in JavaScript that allows you to run scripts in background threads, 
separate from the main UI thread.
This means you can perform heavy computations or asynchronous tasks (e.g., data processing, image manipulation) 
without freezing the UI.                          

ğŸš« The Problem (Before Web Workers)
JavaScript is single-threaded â€” it runs all code on the main thread. So, long-running tasks like:

Parsing large JSON

Complex calculations

Loop-heavy operations

...can block the UI, causing the page to freeze or lag.


âœ… The Solution: Web Workers
Web Workers run code in a separate thread, allowing the main thread to stay responsive.

ğŸ› ï¸ How It Works
1. Create a separate JavaScript file (the worker).

2. Instantiate a Worker in the main script.

3. Communicate using postMessage() and onmessage.

lets see example using react 
----------------------------------
ğŸ§± File Structure (Vite or CRA) 
/public
  â””â”€â”€ counterWorker.js    â† Web Worker file
/src
  â””â”€â”€ App.jsx             â† Main React component
  â””â”€â”€ main.jsx / index.js

ğŸ”¹Step 1: public/counterWorker.js
-------------------------------
let shouldStop = false;

onmessage = function (e) {
  if (e.data === 'start') {
    shouldStop = false;
    let count = 0;
    const limit = 1500000000; // 1.5 billion

    for (let i = 0; i < limit; i++) {
      if (shouldStop) {
        postMessage('Counting stopped by user.');
        return;
      }
      count++;
    }

    postMessage(`Counting done: ${count}`);
  } else if (e.data === 'stop') {
    shouldStop = true;
  }
};
--------------------------------------
ğŸ”¹ Step 2: src/App.jsx
-----------------------------
let shouldStop = false;

onmessage = function (e) {
  if (e.data === 'start') {
    shouldStop = false;
    let count = 0;
    const limit = 1500000000; // 1.5 billion

    for (let i = 0; i < limit; i++) {
      if (shouldStop) {
        postMessage('Counting stopped by user.');
        return;
      }
      count++;
    }

    postMessage(`Counting done: ${count}`);
  } else if (e.data === 'stop') {
    shouldStop = true;
  }
};
shouldStop flag lets the worker exit early if the stop button is pressed.
-----------------------------------------------------------

âœ… Whatâ€™s Happening?
startCounting() creates a new Worker from public/counterWorker.js

Worker runs the heavy loop in the background

If stopCounting() is clicked, it sends a "stop" message

Worker sets shouldStop = true and exits early

The UI stays smooth! 

ğŸ§ª Test it
Run your app (npm run dev or npm start) and open the browser:

Click Start Counting â€“ counting starts

Click Stop Counting â€“ worker stops early and sends a message

ğŸ” Communication Flow
Main thread âœ Worker: worker.postMessage(data)

Worker âœ Main thread: postMessage(result) inside the worker

Both use onmessage event listeners to receive messages.

ğŸ§  Use Cases
Image or video processing

Data compression or encryption

IndexedDB or file parsing

Complex math calculations (e.g., simulations)

Real-time analytics

ğŸš« Limitations
No access to DOM (it's isolated from the UI thread)

No access to window, document, or alert

Only accessible via messaging (postMessage)

Needs to be served over HTTP(s), not file://

âš™ï¸ Terminate Worker
To stop a worker:
---------------------------
worker.terminate();






Q15) What is generator function? 
Ans:- A generator function in JavaScript is a special type of function that can pause and resume execution. 
Itâ€™s defined using the function* syntax and uses the yield keyword.

example-
-------------------------------------
function* myGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = myGenerator();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }

Each call to next() resumes from where it left off.

ğŸ§  Key Concepts
Keyword	Meaning
function*	- Declares a generator
yield	    - Pauses the function and sends out a value
next()	  - Resumes the generator, returns { value, done }
return	  - Ends the generator early (optional return value)
yield*	  - Delegates to another generator 

âœ… Use Cases
1. Custom Iterators

function* range(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}

for (const num of range(1, 5)) {
  console.log(num); // 1 to 5
}


2. Infinite Sequences

function* idGenerator() {
  let id = 0;
  while (true) {
    yield id++;
  }
}

const ids = idGenerator();
console.log(ids.next().value); // 0
console.log(ids.next().value); // 1

3. Asynchronous Control Flow (with async generators) 

async function* fetchPages() {
  let page = 1;
  while (page <= 3) {
    const data = await fetch(`/api/data?page=${page}`).then(res => res.json());
    yield data;
    page++;
  }
}

â›“ï¸ Integration Example in React
Use a generator to simulate a typewriter effect:
function* typeWriter(text) {
  for (let i = 0; i <= text.length; i++) {
    yield text.slice(0, i);
  }
}

Use in React with a timeout loop: 
const [text, setText] = useState('');
useEffect(() => {
  const gen = typeWriter('Hello world!');
  const interval = setInterval(() => {
    const next = gen.next();
    if (next.done) clearInterval(interval);
    else setText(next.value);
  }, 100);
  return () => clearInterval(interval);
}, []);


ğŸŸ¡ Generator vs Async/Await 

| Feature       | Generator            | Async/Await      |
| ------------- | -------------------- | ---------------- |
| Syntax        | `function*`, `yield` | `async`, `await` |
| Sync or Async | Sync                 | Async            |
| Use Case      | Iteration, pausing   | Promises, I/O    |


Q16) What is Observer in js?
Ans:-In JavaScript, an observer is an object or function that monitors a specific subject (another object or system event) and is automatically notified when that subject's state changes. This concept is central to the Observer design pattern and several built-in Web APIs. 

The Observer Design Pattern
-------------------------------------
The Observer design pattern is a behavioral pattern that establishes a one-to-many dependency between objects without making them tightly coupled. 

Subject (Observable): The object that holds the important state and maintains a list of observers. It provides methods to subscribe (subscribe/addEventListener), unsubscribe (unsubscribe/removeEventListener), and notify (notify/dispatch) observers of changes.

Observer (Subscriber): An object (often just a callback function in JS) with an update method that gets called by the subject when a change occurs. Observers can be added or removed dynamically at runtime. 

This pattern promotes loose coupling, making code more flexible and easier to maintain. It is the basis for event handling systems and reactive programming. 

Built-in JavaScript Observer APIs 
-------------------------------------
Modern browsers provide several powerful, specialized Observer APIs for handling specific types of changes efficiently: 

a) Event Listeners: The most common form, used with addEventListener() to react to user interactions (like clicks, keypresses) or system events on the DOM.

b) Mutation Observer: Watches for changes in the DOM tree, such as elements being added, removed, or their attributes/text content modified. This is useful for integrating with third-party scripts or implementing undo/redo functionality.

c) Intersection Observer: Asynchronously monitors when a target element enters or leaves the browser's viewport (or another specified root element). This is widely used for lazy-loading images, infinite scrolling, or triggering animations as elements become visible.

d) Resize Observer: Tracks changes to the size of an element's content box, allowing for the creation of responsive components that adapt to dynamic size changes.

e) Performance Observer: Monitors performance- related events, such as resource loading times or long tasks that might block the main thread, to help optimize application performance. 

Q17) What is debauncing and Throttling ?
Ans :- Debouncing and throttling are performance optimization techniques in JavaScript used to control how often a function executes in response to high-frequency events like scrolling, resizing, or user input. They prevent excessive function calls, which can cause lag and performance issues. They prevent excessive function calls, which can cause lag and performance issues. 

**Debouncing**
----------------------------
Debouncing ensures that a function is executed only after a specific period of inactivity has passed since the last time the event was triggered. It is ideal when you only care about the final state after a series of rapid events. 
Execution Timing: The function runs once, a specified time after the events stop occurring.
Analogy: Waiting for an elevator door to close; it only closes when no one has pressed the "open" button for a certain amount of time, with each button press resetting the timer.
Use Cases:
Search input fields: Fetching search results only after the user has finished typing to avoid unnecessary API calls on every keystroke.
Window resize: Recalculating layout or redrawing UI elements only after the user has finished resizing the window.
Auto-save: Saving form data to a backend after the user pauses typing. 

  e.g.
  --------------------------------------------------------------------------
  function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        const context = this;
        clearTimeout(timeoutId); // Clear the previous timer with every new event
        timeoutId = setTimeout(() => {
            func.apply(context, args); // Call the function after the delay
        }, delay);
    };
}

// Usage:
const handleSearch = debounce((query) => {
    console.log('API call with query:', query);
}, 500); // 500ms delay

document.getElementById('searchInput').addEventListener('input', (event) => {
    handleSearch(event.target.value);
});

----------------------------------------------------------------------------

**Throttling**
-----------------------
Throttling limits the number of times a function can be called within a given time frame. It ensures the function executes at most once per specified interval, regardless of how many times the event is triggered during that period. 

-Execution Timing: The function runs at regular intervals while the events are continuously occurring.
-Analogy: A machine gun that can fire at most once every 100 milliseconds; subsequent clicks within that interval are ignored.

-Use Cases:
  -Scroll events: Implementing infinite scroll or lazy loading of images periodically while the user is scrolling.
  -Mouse movement tracking: Tracking mouse position for performance-sensitive tasks at a controlled rate.
  -Button clicks: Preventing a user from spam-clicking a submit button multiple times in quick succession. 

e.g.
------------------------------------------------------------------------------------
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        const context = this;
        if (!inThrottle) {
            func.apply(context, args); // Execute the function immediately
            inThrottle = true;
            setTimeout(() => {
                inThrottle = false; // Allow subsequent calls after the limit
            }, limit);
        }
    };
}

// Usage:
const handleScroll = throttle(() => {
    console.log('Scrolled!');
}, 100); // at most once every 100ms

window.addEventListener('scroll', handleScroll);
-------------------------------------------------------------------------------------

Key Differences Summary
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Aspect         |   Debauncing                                                        |   Debauncing  
---------------|---------------------------------------------------------------------|------------------------------------------------------------------------------
Execution      | Executes only after a period of inactivity.                         | Executes at most once per fixed time interval.
---------------|---------------------------------------------------------------------|------------------------------------------------------------------------------
Trigger        | Triggered on the "trailing" edge (after events stop).               | Triggered at regular, fixed intervals (leading/trailing edge options exist).
---------------|---------------------------------------------------------------------|------------------------------------------------------------------------------
Use Case       | Search bars, form validation, window resize (final state matters).  | Scrolling, mouse move, game shooting (continuous updates needed).
---------------------------------------------------------------------------------------------------------------------------------------------------------------------   

Many developers opt to use production-ready and well-tested functions from libraries like Lodash which provide robust implementations of both debounce and throttle. 

Q18 ) What is prototype and prototype inheritance ?
Ans:- In programming, we often want to take something and extend it, means we want to achive DRY principles while programming.

For instance, we have a user object with its properties and methods, and want to make admin and guest as slightly modified variants of it. Weâ€™d like to reuse what we have in user, not copy/reimplement its methods, just build a new object on top of it.

Prototypal inheritance is a language feature that helps in that.

[[Prototype]]
-------------------------
In JavaScript, objects have a special hidden property [[Prototype]] (as named in the specification), that is either null or references another object. That object is called â€œa prototypeâ€. When we read a property from object, and itâ€™s missing, JavaScript automatically takes it from the prototype.

The property [[Prototype]] is internal and hidden, but there are many ways to set it.
One of them is to use the special name __proto__, like this:
--------------------------------------------------------------
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; // sets rabbit.[[Prototype]] = animal

// we can find both properties in rabbit now:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true
-------------------------------------------------------------

Now if we read a property from rabbit, and itâ€™s missing, JavaScript will automatically take it from animal.

Here we can say that â€œanimal is the prototype of rabbitâ€ or â€œrabbit prototypically inherits from animalâ€.

So if animal has a lot of useful properties and methods, then they become automatically available in rabbit. Such properties are called â€œinheritedâ€.

If we have a method in animal, it can be called on rabbit:
------------------------------------------------------------
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

// walk is taken from the prototype
rabbit.walk(); // Animal walk
---------------------------------------------------------

The prototype chain can be longer:
-----------------------------------------------------
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

// walk is taken from the prototype chain
longEar.walk(); // Animal walk
alert(longEar.jumps); // true (from rabbit)
----------------------------------------------------

Now if we read something from longEar, and itâ€™s missing, JavaScript will look for it in rabbit, and then in animal.

There are only two limitations:
-------------------------------
  1) The references canâ€™t go in circles. JavaScript will throw an error if we try to assign __proto__ in a circle.
  2) The value of __proto__ can be either an object or null. Other types are ignored.

Prototype chain traversal:
-----------------------------------
  -Property/method lookup traverses from the object â†’ prototype â†’ prototypeâ€™s prototype â†’ â€¦ â†’ null.
  -Breaking the chain by setting __proto__ to null removes inheritance and affects instanceof checks.

Best practices:
-----------------------------------
  -Do not manually modify __proto__ in production code as it can cause bugs and messy code.
  -Use built-in functions like Object.create() for inheritance.
  -Understand prototype inheritance for debugging and writing efficient JavaScript.\

Q19) What is Garbage collection in js ?
Ans:- Garbage Collection (GC) is the automatic process of freeing memory that is no longer reachable or used by the program.

ğŸ‘‰ JavaScript handles memory management automatically.

Simply put, â€œreachableâ€ values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.

1. Thereâ€™s a base set of inherently reachable values, that cannot be deleted for obvious reasons.

For instance:

  -The currently executing function, its local variables and parameters.
  -Other functions on the current chain of nested calls, their local   variables and parameters.
  -Global variables.
  -(there are some other, internal ones as well)
These values are called roots.

2. Any other value is considered reachable if itâ€™s reachable from a root by a reference or by a chain of references.

For instance, if thereâ€™s an object in a global variable, and that object has a property referencing another object, that object is considered reachable. And those that it references are also reachable. Detailed examples to follow.

Thereâ€™s a background process in the JavaScript engine that is called garbage collector. It monitors all objects and removes those that have become unreachable.

A simple example
--------------------------------------
// user has a reference to the object
let user = {
  name: "John"
};
--------------------------------------
 The global variable "user" references the object {name: "John"}. The "name" property of John stores a primitive, so itâ€™s painted inside the object.

 If the value of user is overwritten, the reference is lost:
 ------------------
 user=null
 -----------------
Now John becomes unreachable. Thereâ€™s no way to access it, no references to it. Garbage collector will junk the data and free the memory.

--Another Example 
Now letâ€™s imagine we copied the reference from user to admin:
-------------------------------------
// user has a reference to the object
let user = {
  name: "John"
};

let admin = user;
-------------------------------------

Now if we do the same:
------------------------------
user = null;
------------------------------
â€¦Then the object is still reachable via admin global variable, so it must stay in memory. If we overwrite admin too, then it can be removed.

-Interlinked objects
  Now a more complex example. The family:
--------------------------------------------
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});
------------------------------------------
Function marry â€œmarriesâ€ two objects by giving them references to each other and returns a new object that contains them both.

As of now, all objects are reachable.
Now letâ€™s remove two references:
----------------------------------
delete family.father;
delete family.mother.husband;
----------------------------------
Itâ€™s not enough to delete only one of these two references, because all objects would still be reachable.

But if we delete both, then we can see that John has no incoming reference any more:

Outgoing references do not matter. Only incoming ones can make an object reachable. So, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.

After garbage collection:

Unreachable island
----------------------------
It is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.

The source object is the same as above. Then:
----------------------------------------------
family = null;
--------------------------------------

This example demonstrates how important the concept of reachability is.

Itâ€™s obvious that John and Ann are still linked, both have incoming references. But thatâ€™s not enough.

The former "family" object has been unlinked from the root, thereâ€™s no reference to it any more, so the whole island becomes unreachable and will be removed.

Summary
---------------------
The main things to know:

--Garbage collection is performed automatically. We cannot force or   prevent it.
--Objects are retained in memory while they are reachable.
--Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole, as weâ€™ve seen in the example above.
  
Q20) Weakmap vs Weakset in js?
Ans:- As we know from the Garbage collection, JavaScript engine keeps a value in memory while it is â€œreachableâ€ and can potentially be used.

For Instance 
----------------------------------------------------------
let john = { name: "John" };

// the object can be accessed, john is the reference to it

// overwrite the reference
john = null;

// the object will be removed from memory
----------------------------------------------------------

WeakMap
-------
The first difference between Map and WeakMap is that keys must be objects, not primitive values:
------------------------------------------------------------------------
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // works fine (object key)

// can't use a string as the key
weakMap.set("test", "Whoops"); // Error, because "test" is not an object
--------------------------------------------------------------------------

Now, if we use an object as the key in it, and there are no other references to that object â€“ it will be removed from memory (and from the map) automatically.
-----------------------------------------
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // overwrite the reference

// john is removed from memory!
----------------------------------------

WeakMap does not support iteration and methods keys(), values(), entries(), so thereâ€™s no way to get all keys or values from it.

WeakMap has only the following methods:
---------------------------------------
weakMap.set(key, value)
weakMap.get(key)
weakMap.delete(key)
weakMap.has(key)
-------------------------------------

Use case: caching
------------------
Another common example is caching. We can store (â€œcacheâ€) results from a function, so that future calls on the same object can reuse it.

To achieve that, we can use Map (not optimal scenario):
---------------------------------------------------------------------------------
// ğŸ“ cache.js
let cache = new Map();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculations of the result for */ obj;

    cache.set(obj, result);
    return result;
  }

  return cache.get(obj);
}

// Now we use process() in another file:

// ğŸ“ main.js
let obj = {/* let's say we have an object */};

let result1 = process(obj); // calculated

// ...later, from another place of the code...
let result2 = process(obj); // remembered result taken from cache

// ...later, when the object is not needed any more:
obj = null;

alert(cache.size); // 1 (Ouch! The object is still in cache, taking memory!)
----------------------------------------------------------------------------------

For multiple calls of process(obj) with the same object, it only calculates the result the first time, and then just takes it from cache. The downside is that we need to clean cache when the object is not needed any more.

If we replace Map with WeakMap, then this problem disappears. The cached result will be removed from memory automatically after the object gets garbage collected.
-------------------------------------------------------------------------------------
// ğŸ“ cache.js
let cache = new WeakMap();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculate the result for */ obj;

    cache.set(obj, result);
    return result;
  }

  return cache.get(obj);
}

// ğŸ“ main.js
let obj = {/* some object */};

let result1 = process(obj);
let result2 = process(obj);

// ...later, when the object is not needed any more:
obj = null;

// Can't get cache.size, as it's a WeakMap,
// but it's 0 or soon be 0
// When obj gets garbage collected, cached data will be removed as well
---------------------------------------------------------------------------------

Weakset
------------------------
WeakSet behaves similarly:

-It is analogous to Set, but we may only add objects to WeakSet (not primitives).
-An object exists in the set while it is reachable from somewhere else.
-Like Set, it supports add, has and delete, but not size, keys() and no iterations.

Being â€œweakâ€, it also serves as additional storage. But not for arbitrary data, rather for â€œyes/noâ€ facts. A membership in WeakSet may mean something about the object.

For instance, we can add users to WeakSet to keep track of those who visited our site:
------------------------------------------------
let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John visited us
visitedSet.add(pete); // Then Pete
visitedSet.add(john); // John again

// visitedSet has 2 users now

// check if John visited?
alert(visitedSet.has(john)); // true

// check if Mary visited?
alert(visitedSet.has(mary)); // false

john = null;

// visitedSet will be cleaned automatically
-------------------------------------------------------------

The most notable limitation of WeakMap and WeakSet is the absence of iterations, and the inability to get all current content. That may appear inconvenient, but does not prevent WeakMap/WeakSet from doing their main job â€“ be an â€œadditionalâ€ storage of data for objects which are stored/managed at another place.


Summary
----------------
-WeakMap is Map-like collection that allows only objects as keys and removes them together with associated value once they become inaccessible by other means.

-WeakSet is Set-like collection that stores only objects and removes them once they become inaccessible by other means.

-Their main advantages are that they have weak reference to objects, so they can easily be removed by garbage collector.

-That comes at the cost of not having support for clear, size, keys, valuesâ€¦

-WeakMap and WeakSet are used as â€œsecondaryâ€ data structures in addition to the â€œprimaryâ€ object storage. Once the object is removed from the primary storage, if it is only found as the key of WeakMap or in a WeakSet, it will be cleaned up automatically.

Q21) What is web worker? 
Ans:- JavaScript executes all code on a single main thread, responsible for handling tasks like DOM updates, user events, animations, API calls, and timers. When a heavy or CPU-intensive operation runs on this main thread, it blocks other tasks, resulting in poor user experience, unresponsive interfaces, and potential browser warnings about unresponsive scripts.

practical example involving two buttons on a webpage: one triggers a heavy calculation (summing numbers from 0 to 10 billion), and the other changes the background color of the page. When both tasks run on the main thread, clicking the heavy calculation button prevents the background color button from responding until the calculation finishes, demonstrating blocking behavior.

To solve this, you can introduces web workers, which run JavaScript in separate background threads parallel to the main thread. By moving the expensive calculation into a worker thread, the background color button remains responsive regardless of the heavy computationâ€™s state. The main thread handles UI interactions smoothly while the worker performs CPU-intensive tasks independently.

script.js
-------------------------------------------------------------------------
const webWorker = new Worker("worker.js");
const totalSumBtn = document.querySelector("#totalSumButton");
const bgBtn = document.querySelector("#bgBtn");

totalSumBtn.addEventListener("click", ()=>{
  worker.postMessage("sum");
})

worker.onmessage = function("message"){
  alert(`your total sum is ${message.data}`);
}

bgBtn.addEventListener("click", ()=>{
  if(document.body.style.background !== "red"){
    document.body.style.background= "red" ;
  }else{
    document.body.style.background = "white" ;
  }
})
----------------------------------------------------------------

worker.js 
-----------------------------------------------------------------------
self.onmessage = function(message){
        console.log("message", message);

        if(message.data === "sum"){
          let sum = 0;
           for(let i = 0;i < 100000000000000 ; i++ ){
            sum = sum + i;
           }

           self.message(sum);
        }
}
------------------------------------------------------------------


Key Concepts and Workflow
-----------------------------
-Single-threaded JavaScript: Only one operation executes at a time on the main thread.
-Blocking operations: Heavy tasks block the main thread, delaying UI updates and user interactions.
-Web workers: Enable background threads for parallel execution of heavy tasks.
-Communication between main thread and worker:
  -postMessage: Sends messages between main thread and worker.
  -onmessage: Event listener to receive messages.
-Limitations: Web workers cannot access the DOM or window objects directly.

Implementation Overview
----------------------------
-Create a worker script (worker.js) containing the expensive computation.
-In the main script (script.js), instantiate the worker with new Worker("worker.js").
-Send a message (postMessage) from the main thread to the worker to trigger the calculation.
-In the worker, listen for the message with self.onmessage and, upon receiving the command, run the expensive loop.
-After computation, use self.postMessage to send the result back to the main thread.
-The main thread listens for the workerâ€™s response via worker.onmessage and updates the UI accordingly.
-Meanwhile, UI interactions like changing background color remain responsive because the heavy calculation runs off the main thread.

Benefits of Web Workers
----------------------------
-Improved responsiveness: UI remains interactive during CPU-intensive tasks.
-True parallelism: Web workers run concurrently with the main thread.
-Better user experience: Prevents browser warnings and UI freezes.
-Ease of communication: Simple message passing mechanism for coordination.

Limitations and Important Notes
---------------------------------------------------------------------------------------------------------
Limitation	                  |     Explaination
---------------------------------------------------------------------------------------------------
No DOM access	                |  Workers cannot manipulate HTML elements or access window or document.
Communication overhead	      |  Passing messages between threads involves serialization costs.
Restricted API availability   |	Some browser APIs are unavailable inside workers.
-------------------------------------------------------------------------------------------------------

Key Insights
--------------------------
-JavaScriptâ€™s single-threading model can cause UI blocking under heavy computation.
-Web workers allow offloading CPU-intensive tasks to background threads, preventing UI lag.
-Communication between the main thread and worker threads is done via postMessage and onmessage.
-Web workers do not have access to the DOM, requiring separation of concerns between UI updates and computation.
-Using web workers is essential for maintaining smooth, responsive web applications when processing large data or complex calculations.